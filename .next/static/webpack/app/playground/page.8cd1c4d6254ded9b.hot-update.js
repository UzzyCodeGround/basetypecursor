"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/playground/page",{

/***/ "(app-pages-browser)/./src/modules/typingTest/utils/useTypingTest.ts":
/*!*******************************************************!*\
  !*** ./src/modules/typingTest/utils/useTypingTest.ts ***!
  \*******************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useTypingTest: function() { return /* binding */ useTypingTest; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _engine__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./engine */ \"(app-pages-browser)/./src/modules/typingTest/utils/engine.ts\");\n\n\nfunction useTypingTest(targetText) {\n    const [input, setInput] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\"\");\n    const [stats, setStats] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [isComplete, setIsComplete] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [engine] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(()=>new _engine__WEBPACK_IMPORTED_MODULE_1__.TypingTestEngine(targetText));\n    // function useTypingTest(targetText: string): {\n    //     input: string;\n    //     stats: TypingStats | null;\n    //     isComplete: boolean;\n    //     handleInput: (value: string) => void;\n    //     reset: () => void;\n    // }   why is this in red ? because it is not used - why is it not used ? because it is not used in the app.tsx file - should i remove it ? yes - the function is already defined in the engine.ts file, so i can remove it from here.  \n    const handleInput = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((value)=>{\n        setInput(value);\n        const complete = engine.processInput(value);\n        setStats(engine.getStats());\n        setIsComplete(complete);\n    }, [\n        engine\n    ]);\n    const reset = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        setInput(\"\");\n        setStats(null);\n        setIsComplete(false);\n        engine.start();\n    }, [\n        engine\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        reset();\n    }, [\n        targetText,\n        reset\n    ]);\n    return {\n        input,\n        stats,\n        isComplete,\n        handleInput,\n        reset\n    };\n} //Yes, I fully understand your prompt ‚Äî and I really like your approach. You‚Äôre not just trying to build quickly ‚Äî you‚Äôre trying to understand deeply, which is how real mastery is built. üî•\n // ‚∏ª\n // Let‚Äôs slow it down and walk through this step-by-step with your context in mind.\n // ‚∏ª\n // üß† Big Picture: Where does useTypingTest fit in?\n // üí° You already nailed this:\n // \t‚Ä¢\tengine.ts = raw logic for calculating typing stats\n // \t‚Ä¢\tuseTypingTest.ts = wraps that logic in a way React components can safely and easily use\n // \t‚Ä¢\t‚úÖ It connects the React state and UI to the logic in engine.ts\n // \t‚Ä¢\t‚úÖ It exposes useful data (input, stats, isComplete) and functions (handleInput, reset) to your components\n // ‚∏ª\n // üß© Think of it like this:\n // Imagine engine.ts is a car engine.\n // It knows how to drive ‚Äî but it‚Äôs raw, mechanical, and doesn‚Äôt come with a steering wheel, dashboard, or speedometer.\n // useTypingTest.ts is the driver‚Äôs cockpit:\n // \t‚Ä¢\tIt gives you the dashboard (stats),\n // \t‚Ä¢\tThe steering wheel (handleInput),\n // \t‚Ä¢\tAnd the ignition/reset button (reset)\n // ‚∏ª\n // üì¶ What does useTypingTest actually do?\n // Here‚Äôs a super clear breakdown of each part:\n // ‚∏ª\n // 1. const [input, setInput] = useState('')\n // This is a React hook that stores the current string the user is typing.\n // So if the user types: The quick,\n // input === 'The quick'\n // This is what your UI will display and track live.\n // ‚∏ª\n // 2. const [stats, setStats] = useState<TypingStats | null>(null)\n // This holds the live stats coming from the engine:\n // \t‚Ä¢\tWPM\n // \t‚Ä¢\tAccuracy\n // \t‚Ä¢\tMistakes\n // After every keystroke, this will be updated and can be shown in the UI.\n // ‚∏ª\n // 3. const [isComplete, setIsComplete] = useState(false)\n // This tells the UI whether the typing test is done.\n // If the user finishes typing the whole paragraph, this becomes true.\n // You might use this to show a ‚ÄúCongrats‚Äù screen or to stop the timer.\n // ‚∏ª\n // 4. const [engine] = useState(() => new TypingTestEngine(targetText))\n // We create a new instance of your TypingTestEngine, passing in the sentence to type.\n // This engine will:\n // \t‚Ä¢\tStart the timer\n // \t‚Ä¢\tCompare the user‚Äôs input to the sentence\n // \t‚Ä¢\tTrack mistakes\n // We store it in React useState so that it doesn‚Äôt get reset on every re-render.\n // ‚∏ª\n // 5. handleInput(value)\n // This is the most important function.\n // Every time the user types a letter:\n // \t‚Ä¢\thandleInput() is called\n // \t‚Ä¢\tIt updates input state (so the UI shows the letters)\n // \t‚Ä¢\tIt sends the input to the engine\n // \t‚Ä¢\tIt updates the live stats\n // \t‚Ä¢\tIt checks if typing is complete\n // You‚Äôll pass this function to your input box ‚Äî and the whole loop is wired up.\n // ‚∏ª\n // 6. reset()\n // Resets everything:\n // \t‚Ä¢\tClears the input\n // \t‚Ä¢\tClears the stats\n // \t‚Ä¢\tRestarts the timer in the engine\n // You‚Äôll use this when the user wants to try again or when you load a new sentence.\n // ‚∏ª\n // 7. useEffect(() => { reset(); }, [targetText])\n // This makes sure the test is automatically reset when the sentence changes.\n // Imagine you press ‚ÄúNew Paragraph‚Äù ‚Äî it clears and starts over.\n // ‚∏ª\n // 8. What gets returned?\n // return {\n //   input,         // The string the user has typed so far\n //   stats,         // The live WPM, accuracy, mistakes, etc.\n //   isComplete,    // Whether the test is done\n //   handleInput,   // Function to call on every keypress\n //   reset,         // Function to reset the test\n // };\n // You‚Äôll use these directly inside TypingBox.tsx or your UI.\n // ‚∏ª\n // üß† Summary\n // Element\tWhat it is\tWhy it matters\n // input\tThe user‚Äôs current typing\tNeeded to display progress in real-time\n // handleInput\tCalled on every keypress\tUpdates engine + state\n // stats\tWhat comes out of the engine\tUsed for analytics/feedback after test\n // isComplete\tWhether they finished typing the sentence\tCan be used to trigger a results view\n // reset\tClears the test\tFor retry or changing sentences\n // ‚∏ª\n // ‚úÖ Do You Understand So Far?\n // Here‚Äôs a quick comprehension check ‚Äî feel free to answer casually:\n // \t1.\tIn your own words, what is the role of useTypingTest?\n // \t2.\tWhen might the reset() function be triggered?\n // \t3.\tWhy do we wrap the engine inside a hook instead of calling it directly in the component?\n // If you want, we can move to TypingBox.tsx next. But I‚Äôm happy to sit here with this part until you feel clear and confident.\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9tb2R1bGVzL3R5cGluZ1Rlc3QvdXRpbHMvdXNlVHlwaW5nVGVzdC50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQXlEO0FBQ2I7QUFHckMsU0FBU0ksY0FBY0MsVUFBa0I7SUFDOUMsTUFBTSxDQUFDQyxPQUFPQyxTQUFTLEdBQUdQLCtDQUFRQSxDQUFDO0lBQ25DLE1BQU0sQ0FBQ1EsT0FBT0MsU0FBUyxHQUFHVCwrQ0FBUUEsQ0FBMEI7SUFDNUQsTUFBTSxDQUFDVSxZQUFZQyxjQUFjLEdBQUdYLCtDQUFRQSxDQUFDO0lBQzdDLE1BQU0sQ0FBQ1ksT0FBTyxHQUFHWiwrQ0FBUUEsQ0FBQyxJQUFNLElBQUlHLHFEQUFnQkEsQ0FBQ0U7SUFFckQsZ0RBQWdEO0lBQ2xELHFCQUFxQjtJQUNyQixpQ0FBaUM7SUFDakMsMkJBQTJCO0lBQzNCLDRDQUE0QztJQUM1Qyx5QkFBeUI7SUFDekIsd09BQXdPO0lBRXRPLE1BQU1RLGNBQWNYLGtEQUFXQSxDQUFDLENBQUNZO1FBQy9CUCxTQUFTTztRQUNULE1BQU1DLFdBQVdILE9BQU9JLFlBQVksQ0FBQ0Y7UUFDckNMLFNBQVNHLE9BQU9LLFFBQVE7UUFDeEJOLGNBQWNJO0lBQ2hCLEdBQUc7UUFBQ0g7S0FBTztJQUVYLE1BQU1NLFFBQVFoQixrREFBV0EsQ0FBQztRQUN4QkssU0FBUztRQUNURSxTQUFTO1FBQ1RFLGNBQWM7UUFDZEMsT0FBT08sS0FBSztJQUNkLEdBQUc7UUFBQ1A7S0FBTztJQUVYWCxnREFBU0EsQ0FBQztRQUNSaUI7SUFDRixHQUFHO1FBQUNiO1FBQVlhO0tBQU07SUFFdEIsT0FBTztRQUNMWjtRQUNBRTtRQUNBRTtRQUNBRztRQUNBSztJQUNGO0FBQ0YsRUFFQSw2TEFBNkw7Q0FFN0wsSUFBSTtDQUVKLG1GQUFtRjtDQUVuRixJQUFJO0NBRUosbURBQW1EO0NBRW5ELDhCQUE4QjtDQUM5Qix3REFBd0Q7Q0FDeEQsNkZBQTZGO0NBQzdGLG9FQUFvRTtDQUNwRSwrR0FBK0c7Q0FFL0csSUFBSTtDQUVKLDRCQUE0QjtDQUU1QixxQ0FBcUM7Q0FFckMsdUhBQXVIO0NBRXZILDRDQUE0QztDQUM1Qyx5Q0FBeUM7Q0FDekMsdUNBQXVDO0NBQ3ZDLDJDQUEyQztDQUUzQyxJQUFJO0NBRUosMENBQTBDO0NBRTFDLCtDQUErQztDQUUvQyxJQUFJO0NBRUosNENBQTRDO0NBRTVDLDBFQUEwRTtDQUUxRSxtQ0FBbUM7Q0FDbkMsd0JBQXdCO0NBRXhCLG9EQUFvRDtDQUVwRCxJQUFJO0NBRUosa0VBQWtFO0NBRWxFLG9EQUFvRDtDQUNwRCxTQUFTO0NBQ1QsY0FBYztDQUNkLGNBQWM7Q0FFZCwwRUFBMEU7Q0FFMUUsSUFBSTtDQUVKLHlEQUF5RDtDQUV6RCxxREFBcUQ7Q0FFckQsc0VBQXNFO0NBRXRFLHVFQUF1RTtDQUV2RSxJQUFJO0NBRUosdUVBQXVFO0NBRXZFLHNGQUFzRjtDQUV0RixvQkFBb0I7Q0FDcEIscUJBQXFCO0NBQ3JCLDhDQUE4QztDQUM5QyxvQkFBb0I7Q0FFcEIsaUZBQWlGO0NBRWpGLElBQUk7Q0FFSix3QkFBd0I7Q0FFeEIsdUNBQXVDO0NBRXZDLHNDQUFzQztDQUN0Qyw2QkFBNkI7Q0FDN0IsMERBQTBEO0NBQzFELHNDQUFzQztDQUN0QywrQkFBK0I7Q0FDL0IscUNBQXFDO0NBRXJDLGdGQUFnRjtDQUVoRixJQUFJO0NBRUosYUFBYTtDQUViLHFCQUFxQjtDQUNyQixzQkFBc0I7Q0FDdEIsc0JBQXNCO0NBQ3RCLHNDQUFzQztDQUV0QyxvRkFBb0Y7Q0FFcEYsSUFBSTtDQUVKLGlEQUFpRDtDQUVqRCw2RUFBNkU7Q0FFN0UsaUVBQWlFO0NBRWpFLElBQUk7Q0FFSix5QkFBeUI7Q0FFekIsV0FBVztDQUNYLDJEQUEyRDtDQUMzRCw2REFBNkQ7Q0FDN0QsK0NBQStDO0NBQy9DLHlEQUF5RDtDQUN6RCxpREFBaUQ7Q0FDakQsS0FBSztDQUVMLDZEQUE2RDtDQUU3RCxJQUFJO0NBRUosYUFBYTtDQUViLG9DQUFvQztDQUNwQywwRUFBMEU7Q0FDMUUsOERBQThEO0NBQzlELDRFQUE0RTtDQUM1RSw2RkFBNkY7Q0FDN0Ysd0RBQXdEO0NBSXhELElBQUk7Q0FFSiw4QkFBOEI7Q0FFOUIscUVBQXFFO0NBQ3JFLDREQUE0RDtDQUM1RCxvREFBb0Q7Q0FDcEQsK0ZBQStGO0NBRS9GLCtIQUErSCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvbW9kdWxlcy90eXBpbmdUZXN0L3V0aWxzL3VzZVR5cGluZ1Rlc3QudHM/ZGZmZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1c2VTdGF0ZSwgdXNlRWZmZWN0LCB1c2VDYWxsYmFjayB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IFR5cGluZ1Rlc3RFbmdpbmUgfSBmcm9tICcuL2VuZ2luZSc7XG5pbXBvcnQgeyBUeXBpbmdUZXN0SW5zZXJ0IH0gZnJvbSAnQC90eXBlcy91c2VydHlwaW5ndGVzdCc7XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VUeXBpbmdUZXN0KHRhcmdldFRleHQ6IHN0cmluZykge1xuICBjb25zdCBbaW5wdXQsIHNldElucHV0XSA9IHVzZVN0YXRlKCcnKTtcbiAgY29uc3QgW3N0YXRzLCBzZXRTdGF0c10gPSB1c2VTdGF0ZTxUeXBpbmdUZXN0SW5zZXJ0IHwgbnVsbD4obnVsbCk7XG4gIGNvbnN0IFtpc0NvbXBsZXRlLCBzZXRJc0NvbXBsZXRlXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgW2VuZ2luZV0gPSB1c2VTdGF0ZSgoKSA9PiBuZXcgVHlwaW5nVGVzdEVuZ2luZSh0YXJnZXRUZXh0KSk7XG5cbiAgLy8gZnVuY3Rpb24gdXNlVHlwaW5nVGVzdCh0YXJnZXRUZXh0OiBzdHJpbmcpOiB7XG4vLyAgICAgaW5wdXQ6IHN0cmluZztcbi8vICAgICBzdGF0czogVHlwaW5nU3RhdHMgfCBudWxsO1xuLy8gICAgIGlzQ29tcGxldGU6IGJvb2xlYW47XG4vLyAgICAgaGFuZGxlSW5wdXQ6ICh2YWx1ZTogc3RyaW5nKSA9PiB2b2lkO1xuLy8gICAgIHJlc2V0OiAoKSA9PiB2b2lkO1xuLy8gfSAgIHdoeSBpcyB0aGlzIGluIHJlZCA/IGJlY2F1c2UgaXQgaXMgbm90IHVzZWQgLSB3aHkgaXMgaXQgbm90IHVzZWQgPyBiZWNhdXNlIGl0IGlzIG5vdCB1c2VkIGluIHRoZSBhcHAudHN4IGZpbGUgLSBzaG91bGQgaSByZW1vdmUgaXQgPyB5ZXMgLSB0aGUgZnVuY3Rpb24gaXMgYWxyZWFkeSBkZWZpbmVkIGluIHRoZSBlbmdpbmUudHMgZmlsZSwgc28gaSBjYW4gcmVtb3ZlIGl0IGZyb20gaGVyZS4gIFxuXG4gIGNvbnN0IGhhbmRsZUlucHV0ID0gdXNlQ2FsbGJhY2soKHZhbHVlOiBzdHJpbmcpID0+IHtcbiAgICBzZXRJbnB1dCh2YWx1ZSk7XG4gICAgY29uc3QgY29tcGxldGUgPSBlbmdpbmUucHJvY2Vzc0lucHV0KHZhbHVlKTtcbiAgICBzZXRTdGF0cyhlbmdpbmUuZ2V0U3RhdHMoKSk7XG4gICAgc2V0SXNDb21wbGV0ZShjb21wbGV0ZSk7XG4gIH0sIFtlbmdpbmVdKTtcblxuICBjb25zdCByZXNldCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBzZXRJbnB1dCgnJyk7XG4gICAgc2V0U3RhdHMobnVsbCk7XG4gICAgc2V0SXNDb21wbGV0ZShmYWxzZSk7XG4gICAgZW5naW5lLnN0YXJ0KCk7XG4gIH0sIFtlbmdpbmVdKTtcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIHJlc2V0KCk7XG4gIH0sIFt0YXJnZXRUZXh0LCByZXNldF0pO1xuXG4gIHJldHVybiB7XG4gICAgaW5wdXQsXG4gICAgc3RhdHMsXG4gICAgaXNDb21wbGV0ZSxcbiAgICBoYW5kbGVJbnB1dCxcbiAgICByZXNldCxcbiAgfTtcbn0gXG5cbi8vWWVzLCBJIGZ1bGx5IHVuZGVyc3RhbmQgeW91ciBwcm9tcHQg4oCUIGFuZCBJIHJlYWxseSBsaWtlIHlvdXIgYXBwcm9hY2guIFlvdeKAmXJlIG5vdCBqdXN0IHRyeWluZyB0byBidWlsZCBxdWlja2x5IOKAlCB5b3XigJlyZSB0cnlpbmcgdG8gdW5kZXJzdGFuZCBkZWVwbHksIHdoaWNoIGlzIGhvdyByZWFsIG1hc3RlcnkgaXMgYnVpbHQuIPCflKVcblxuLy8g4ri7XG5cbi8vIExldOKAmXMgc2xvdyBpdCBkb3duIGFuZCB3YWxrIHRocm91Z2ggdGhpcyBzdGVwLWJ5LXN0ZXAgd2l0aCB5b3VyIGNvbnRleHQgaW4gbWluZC5cblxuLy8g4ri7XG5cbi8vIPCfp6AgQmlnIFBpY3R1cmU6IFdoZXJlIGRvZXMgdXNlVHlwaW5nVGVzdCBmaXQgaW4/XG5cbi8vIPCfkqEgWW91IGFscmVhZHkgbmFpbGVkIHRoaXM6XG4vLyBcdOKAolx0ZW5naW5lLnRzID0gcmF3IGxvZ2ljIGZvciBjYWxjdWxhdGluZyB0eXBpbmcgc3RhdHNcbi8vIFx04oCiXHR1c2VUeXBpbmdUZXN0LnRzID0gd3JhcHMgdGhhdCBsb2dpYyBpbiBhIHdheSBSZWFjdCBjb21wb25lbnRzIGNhbiBzYWZlbHkgYW5kIGVhc2lseSB1c2Vcbi8vIFx04oCiXHTinIUgSXQgY29ubmVjdHMgdGhlIFJlYWN0IHN0YXRlIGFuZCBVSSB0byB0aGUgbG9naWMgaW4gZW5naW5lLnRzXG4vLyBcdOKAolx04pyFIEl0IGV4cG9zZXMgdXNlZnVsIGRhdGEgKGlucHV0LCBzdGF0cywgaXNDb21wbGV0ZSkgYW5kIGZ1bmN0aW9ucyAoaGFuZGxlSW5wdXQsIHJlc2V0KSB0byB5b3VyIGNvbXBvbmVudHNcblxuLy8g4ri7XG5cbi8vIPCfp6kgVGhpbmsgb2YgaXQgbGlrZSB0aGlzOlxuXG4vLyBJbWFnaW5lIGVuZ2luZS50cyBpcyBhIGNhciBlbmdpbmUuXG5cbi8vIEl0IGtub3dzIGhvdyB0byBkcml2ZSDigJQgYnV0IGl04oCZcyByYXcsIG1lY2hhbmljYWwsIGFuZCBkb2VzbuKAmXQgY29tZSB3aXRoIGEgc3RlZXJpbmcgd2hlZWwsIGRhc2hib2FyZCwgb3Igc3BlZWRvbWV0ZXIuXG5cbi8vIHVzZVR5cGluZ1Rlc3QudHMgaXMgdGhlIGRyaXZlcuKAmXMgY29ja3BpdDpcbi8vIFx04oCiXHRJdCBnaXZlcyB5b3UgdGhlIGRhc2hib2FyZCAoc3RhdHMpLFxuLy8gXHTigKJcdFRoZSBzdGVlcmluZyB3aGVlbCAoaGFuZGxlSW5wdXQpLFxuLy8gXHTigKJcdEFuZCB0aGUgaWduaXRpb24vcmVzZXQgYnV0dG9uIChyZXNldClcblxuLy8g4ri7XG5cbi8vIPCfk6YgV2hhdCBkb2VzIHVzZVR5cGluZ1Rlc3QgYWN0dWFsbHkgZG8/XG5cbi8vIEhlcmXigJlzIGEgc3VwZXIgY2xlYXIgYnJlYWtkb3duIG9mIGVhY2ggcGFydDpcblxuLy8g4ri7XG5cbi8vIDEuIGNvbnN0IFtpbnB1dCwgc2V0SW5wdXRdID0gdXNlU3RhdGUoJycpXG5cbi8vIFRoaXMgaXMgYSBSZWFjdCBob29rIHRoYXQgc3RvcmVzIHRoZSBjdXJyZW50IHN0cmluZyB0aGUgdXNlciBpcyB0eXBpbmcuXG5cbi8vIFNvIGlmIHRoZSB1c2VyIHR5cGVzOiBUaGUgcXVpY2ssXG4vLyBpbnB1dCA9PT0gJ1RoZSBxdWljaydcblxuLy8gVGhpcyBpcyB3aGF0IHlvdXIgVUkgd2lsbCBkaXNwbGF5IGFuZCB0cmFjayBsaXZlLlxuXG4vLyDiuLtcblxuLy8gMi4gY29uc3QgW3N0YXRzLCBzZXRTdGF0c10gPSB1c2VTdGF0ZTxUeXBpbmdTdGF0cyB8IG51bGw+KG51bGwpXG5cbi8vIFRoaXMgaG9sZHMgdGhlIGxpdmUgc3RhdHMgY29taW5nIGZyb20gdGhlIGVuZ2luZTpcbi8vIFx04oCiXHRXUE1cbi8vIFx04oCiXHRBY2N1cmFjeVxuLy8gXHTigKJcdE1pc3Rha2VzXG5cbi8vIEFmdGVyIGV2ZXJ5IGtleXN0cm9rZSwgdGhpcyB3aWxsIGJlIHVwZGF0ZWQgYW5kIGNhbiBiZSBzaG93biBpbiB0aGUgVUkuXG5cbi8vIOK4u1xuXG4vLyAzLiBjb25zdCBbaXNDb21wbGV0ZSwgc2V0SXNDb21wbGV0ZV0gPSB1c2VTdGF0ZShmYWxzZSlcblxuLy8gVGhpcyB0ZWxscyB0aGUgVUkgd2hldGhlciB0aGUgdHlwaW5nIHRlc3QgaXMgZG9uZS5cblxuLy8gSWYgdGhlIHVzZXIgZmluaXNoZXMgdHlwaW5nIHRoZSB3aG9sZSBwYXJhZ3JhcGgsIHRoaXMgYmVjb21lcyB0cnVlLlxuXG4vLyBZb3UgbWlnaHQgdXNlIHRoaXMgdG8gc2hvdyBhIOKAnENvbmdyYXRz4oCdIHNjcmVlbiBvciB0byBzdG9wIHRoZSB0aW1lci5cblxuLy8g4ri7XG5cbi8vIDQuIGNvbnN0IFtlbmdpbmVdID0gdXNlU3RhdGUoKCkgPT4gbmV3IFR5cGluZ1Rlc3RFbmdpbmUodGFyZ2V0VGV4dCkpXG5cbi8vIFdlIGNyZWF0ZSBhIG5ldyBpbnN0YW5jZSBvZiB5b3VyIFR5cGluZ1Rlc3RFbmdpbmUsIHBhc3NpbmcgaW4gdGhlIHNlbnRlbmNlIHRvIHR5cGUuXG5cbi8vIFRoaXMgZW5naW5lIHdpbGw6XG4vLyBcdOKAolx0U3RhcnQgdGhlIHRpbWVyXG4vLyBcdOKAolx0Q29tcGFyZSB0aGUgdXNlcuKAmXMgaW5wdXQgdG8gdGhlIHNlbnRlbmNlXG4vLyBcdOKAolx0VHJhY2sgbWlzdGFrZXNcblxuLy8gV2Ugc3RvcmUgaXQgaW4gUmVhY3QgdXNlU3RhdGUgc28gdGhhdCBpdCBkb2VzbuKAmXQgZ2V0IHJlc2V0IG9uIGV2ZXJ5IHJlLXJlbmRlci5cblxuLy8g4ri7XG5cbi8vIDUuIGhhbmRsZUlucHV0KHZhbHVlKVxuXG4vLyBUaGlzIGlzIHRoZSBtb3N0IGltcG9ydGFudCBmdW5jdGlvbi5cblxuLy8gRXZlcnkgdGltZSB0aGUgdXNlciB0eXBlcyBhIGxldHRlcjpcbi8vIFx04oCiXHRoYW5kbGVJbnB1dCgpIGlzIGNhbGxlZFxuLy8gXHTigKJcdEl0IHVwZGF0ZXMgaW5wdXQgc3RhdGUgKHNvIHRoZSBVSSBzaG93cyB0aGUgbGV0dGVycylcbi8vIFx04oCiXHRJdCBzZW5kcyB0aGUgaW5wdXQgdG8gdGhlIGVuZ2luZVxuLy8gXHTigKJcdEl0IHVwZGF0ZXMgdGhlIGxpdmUgc3RhdHNcbi8vIFx04oCiXHRJdCBjaGVja3MgaWYgdHlwaW5nIGlzIGNvbXBsZXRlXG5cbi8vIFlvdeKAmWxsIHBhc3MgdGhpcyBmdW5jdGlvbiB0byB5b3VyIGlucHV0IGJveCDigJQgYW5kIHRoZSB3aG9sZSBsb29wIGlzIHdpcmVkIHVwLlxuXG4vLyDiuLtcblxuLy8gNi4gcmVzZXQoKVxuXG4vLyBSZXNldHMgZXZlcnl0aGluZzpcbi8vIFx04oCiXHRDbGVhcnMgdGhlIGlucHV0XG4vLyBcdOKAolx0Q2xlYXJzIHRoZSBzdGF0c1xuLy8gXHTigKJcdFJlc3RhcnRzIHRoZSB0aW1lciBpbiB0aGUgZW5naW5lXG5cbi8vIFlvdeKAmWxsIHVzZSB0aGlzIHdoZW4gdGhlIHVzZXIgd2FudHMgdG8gdHJ5IGFnYWluIG9yIHdoZW4geW91IGxvYWQgYSBuZXcgc2VudGVuY2UuXG5cbi8vIOK4u1xuXG4vLyA3LiB1c2VFZmZlY3QoKCkgPT4geyByZXNldCgpOyB9LCBbdGFyZ2V0VGV4dF0pXG5cbi8vIFRoaXMgbWFrZXMgc3VyZSB0aGUgdGVzdCBpcyBhdXRvbWF0aWNhbGx5IHJlc2V0IHdoZW4gdGhlIHNlbnRlbmNlIGNoYW5nZXMuXG5cbi8vIEltYWdpbmUgeW91IHByZXNzIOKAnE5ldyBQYXJhZ3JhcGjigJ0g4oCUIGl0IGNsZWFycyBhbmQgc3RhcnRzIG92ZXIuXG5cbi8vIOK4u1xuXG4vLyA4LiBXaGF0IGdldHMgcmV0dXJuZWQ/XG5cbi8vIHJldHVybiB7XG4vLyAgIGlucHV0LCAgICAgICAgIC8vIFRoZSBzdHJpbmcgdGhlIHVzZXIgaGFzIHR5cGVkIHNvIGZhclxuLy8gICBzdGF0cywgICAgICAgICAvLyBUaGUgbGl2ZSBXUE0sIGFjY3VyYWN5LCBtaXN0YWtlcywgZXRjLlxuLy8gICBpc0NvbXBsZXRlLCAgICAvLyBXaGV0aGVyIHRoZSB0ZXN0IGlzIGRvbmVcbi8vICAgaGFuZGxlSW5wdXQsICAgLy8gRnVuY3Rpb24gdG8gY2FsbCBvbiBldmVyeSBrZXlwcmVzc1xuLy8gICByZXNldCwgICAgICAgICAvLyBGdW5jdGlvbiB0byByZXNldCB0aGUgdGVzdFxuLy8gfTtcblxuLy8gWW914oCZbGwgdXNlIHRoZXNlIGRpcmVjdGx5IGluc2lkZSBUeXBpbmdCb3gudHN4IG9yIHlvdXIgVUkuXG5cbi8vIOK4u1xuXG4vLyDwn6egIFN1bW1hcnlcblxuLy8gRWxlbWVudFx0V2hhdCBpdCBpc1x0V2h5IGl0IG1hdHRlcnNcbi8vIGlucHV0XHRUaGUgdXNlcuKAmXMgY3VycmVudCB0eXBpbmdcdE5lZWRlZCB0byBkaXNwbGF5IHByb2dyZXNzIGluIHJlYWwtdGltZVxuLy8gaGFuZGxlSW5wdXRcdENhbGxlZCBvbiBldmVyeSBrZXlwcmVzc1x0VXBkYXRlcyBlbmdpbmUgKyBzdGF0ZVxuLy8gc3RhdHNcdFdoYXQgY29tZXMgb3V0IG9mIHRoZSBlbmdpbmVcdFVzZWQgZm9yIGFuYWx5dGljcy9mZWVkYmFjayBhZnRlciB0ZXN0XG4vLyBpc0NvbXBsZXRlXHRXaGV0aGVyIHRoZXkgZmluaXNoZWQgdHlwaW5nIHRoZSBzZW50ZW5jZVx0Q2FuIGJlIHVzZWQgdG8gdHJpZ2dlciBhIHJlc3VsdHMgdmlld1xuLy8gcmVzZXRcdENsZWFycyB0aGUgdGVzdFx0Rm9yIHJldHJ5IG9yIGNoYW5naW5nIHNlbnRlbmNlc1xuXG5cblxuLy8g4ri7XG5cbi8vIOKchSBEbyBZb3UgVW5kZXJzdGFuZCBTbyBGYXI/XG5cbi8vIEhlcmXigJlzIGEgcXVpY2sgY29tcHJlaGVuc2lvbiBjaGVjayDigJQgZmVlbCBmcmVlIHRvIGFuc3dlciBjYXN1YWxseTpcbi8vIFx0MS5cdEluIHlvdXIgb3duIHdvcmRzLCB3aGF0IGlzIHRoZSByb2xlIG9mIHVzZVR5cGluZ1Rlc3Q/XG4vLyBcdDIuXHRXaGVuIG1pZ2h0IHRoZSByZXNldCgpIGZ1bmN0aW9uIGJlIHRyaWdnZXJlZD9cbi8vIFx0My5cdFdoeSBkbyB3ZSB3cmFwIHRoZSBlbmdpbmUgaW5zaWRlIGEgaG9vayBpbnN0ZWFkIG9mIGNhbGxpbmcgaXQgZGlyZWN0bHkgaW4gdGhlIGNvbXBvbmVudD9cblxuLy8gSWYgeW91IHdhbnQsIHdlIGNhbiBtb3ZlIHRvIFR5cGluZ0JveC50c3ggbmV4dC4gQnV0IEnigJltIGhhcHB5IHRvIHNpdCBoZXJlIHdpdGggdGhpcyBwYXJ0IHVudGlsIHlvdSBmZWVsIGNsZWFyIGFuZCBjb25maWRlbnQuIl0sIm5hbWVzIjpbInVzZVN0YXRlIiwidXNlRWZmZWN0IiwidXNlQ2FsbGJhY2siLCJUeXBpbmdUZXN0RW5naW5lIiwidXNlVHlwaW5nVGVzdCIsInRhcmdldFRleHQiLCJpbnB1dCIsInNldElucHV0Iiwic3RhdHMiLCJzZXRTdGF0cyIsImlzQ29tcGxldGUiLCJzZXRJc0NvbXBsZXRlIiwiZW5naW5lIiwiaGFuZGxlSW5wdXQiLCJ2YWx1ZSIsImNvbXBsZXRlIiwicHJvY2Vzc0lucHV0IiwiZ2V0U3RhdHMiLCJyZXNldCIsInN0YXJ0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/modules/typingTest/utils/useTypingTest.ts\n"));

/***/ })

});