"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/playground/page",{

/***/ "(app-pages-browser)/./src/modules/typingTest/server/saveResult.ts":
/*!*****************************************************!*\
  !*** ./src/modules/typingTest/server/saveResult.ts ***!
  \*****************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   saveTypingResult: function() { return /* binding */ saveTypingResult; }\n/* harmony export */ });\n/* harmony import */ var _lib_supabase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/lib/supabase */ \"(app-pages-browser)/./src/lib/supabase.ts\");\n\nasync function saveTypingResult(result) {\n    const { error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"typing_results\").insert([\n        result\n    ]);\n    if (error) {\n        console.error(\"Error saving typing result:\", error.message);\n    } else {\n        console.log(\"‚úÖ Typing result saved to Supabase\");\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9tb2R1bGVzL3R5cGluZ1Rlc3Qvc2VydmVyL3NhdmVSZXN1bHQudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBMEM7QUFXbkMsZUFBZUMsaUJBQWlCQyxNQUFtRTtJQUN4RyxNQUFNLEVBQUVDLEtBQUssRUFBRSxHQUFHLE1BQU1ILG1EQUFRQSxDQUFDSSxJQUFJLENBQUMsa0JBQWtCQyxNQUFNLENBQUM7UUFBQ0g7S0FBTztJQUN2RSxJQUFJQyxPQUFPO1FBQ1RHLFFBQVFILEtBQUssQ0FBQywrQkFBK0JBLE1BQU1JLE9BQU87SUFDNUQsT0FBTztRQUNMRCxRQUFRRSxHQUFHLENBQUM7SUFDZDtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9tb2R1bGVzL3R5cGluZ1Rlc3Qvc2VydmVyL3NhdmVSZXN1bHQudHM/N2VlOSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBzdXBhYmFzZSB9IGZyb20gJ0AvbGliL3N1cGFiYXNlJztcblxuZXhwb3J0IGludGVyZmFjZSBUeXBpbmdTdGF0cyB7XG4gIHdwbTogbnVtYmVyO1xuICBhY2N1cmFjeTogbnVtYmVyO1xuICBtaXN0YWtlczogeyBba2V5OiBzdHJpbmddOiBudW1iZXIgfTtcbiAgdG90YWxUaW1lOiBudW1iZXI7XG4gIHRvdGFsQ2hhcmFjdGVyczogbnVtYmVyO1xuICBjb3JyZWN0Q2hhcmFjdGVyczogbnVtYmVyO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc2F2ZVR5cGluZ1Jlc3VsdChyZXN1bHQ6IFR5cGluZ1N0YXRzICYgeyB1c2VyX2lkPzogc3RyaW5nIHwgbnVsbDsgc2VudGVuY2U6IHN0cmluZyB9KSB7XG4gIGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlLmZyb20oJ3R5cGluZ19yZXN1bHRzJykuaW5zZXJ0KFtyZXN1bHRdKTtcbiAgaWYgKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3Igc2F2aW5nIHR5cGluZyByZXN1bHQ6JywgZXJyb3IubWVzc2FnZSk7XG4gIH0gZWxzZSB7XG4gICAgY29uc29sZS5sb2coJ+KchSBUeXBpbmcgcmVzdWx0IHNhdmVkIHRvIFN1cGFiYXNlJyk7XG4gIH1cbn0iXSwibmFtZXMiOlsic3VwYWJhc2UiLCJzYXZlVHlwaW5nUmVzdWx0IiwicmVzdWx0IiwiZXJyb3IiLCJmcm9tIiwiaW5zZXJ0IiwiY29uc29sZSIsIm1lc3NhZ2UiLCJsb2ciXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/modules/typingTest/server/saveResult.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/modules/typingTest/utils/useTypingTest.ts":
/*!*******************************************************!*\
  !*** ./src/modules/typingTest/utils/useTypingTest.ts ***!
  \*******************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useTypingTest: function() { return /* binding */ useTypingTest; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _engine__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./engine */ \"(app-pages-browser)/./src/modules/typingTest/utils/engine.ts\");\n\n\nfunction useTypingTest(targetText) {\n    const [input, setInput] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\"\");\n    const [stats, setStats] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [isComplete, setIsComplete] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [engine] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(()=>new _engine__WEBPACK_IMPORTED_MODULE_1__.TypingTestEngine(targetText));\n    // function useTypingTest(targetText: string): {\n    //     input: string;\n    //     stats: TypingStats | null;\n    //     isComplete: boolean;\n    //     handleInput: (value: string) => void;\n    //     reset: () => void;\n    // }   why is this in red ? because it is not used - why is it not used ? because it is not used in the app.tsx file - should i remove it ? yes - the function is already defined in the engine.ts file, so i can remove it from here.  \n    const handleInput = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((value)=>{\n        setInput(value);\n        const complete = engine.processInput(value);\n        setStats(engine.getStats());\n        setIsComplete(complete);\n    }, [\n        engine\n    ]);\n    const reset = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        setInput(\"\");\n        setStats(null);\n        setIsComplete(false);\n        engine.start();\n    }, [\n        engine\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        reset();\n    }, [\n        targetText,\n        reset\n    ]);\n    return {\n        input,\n        stats,\n        isComplete,\n        handleInput,\n        reset\n    };\n} //Yes, I fully understand your prompt ‚Äî and I really like your approach. You‚Äôre not just trying to build quickly ‚Äî you‚Äôre trying to understand deeply, which is how real mastery is built. üî•\n // ‚∏ª\n // Let‚Äôs slow it down and walk through this step-by-step with your context in mind.\n // ‚∏ª\n // üß† Big Picture: Where does useTypingTest fit in?\n // üí° You already nailed this:\n // \t‚Ä¢\tengine.ts = raw logic for calculating typing stats\n // \t‚Ä¢\tuseTypingTest.ts = wraps that logic in a way React components can safely and easily use\n // \t‚Ä¢\t‚úÖ It connects the React state and UI to the logic in engine.ts\n // \t‚Ä¢\t‚úÖ It exposes useful data (input, stats, isComplete) and functions (handleInput, reset) to your components\n // ‚∏ª\n // üß© Think of it like this:\n // Imagine engine.ts is a car engine.\n // It knows how to drive ‚Äî but it‚Äôs raw, mechanical, and doesn‚Äôt come with a steering wheel, dashboard, or speedometer.\n // useTypingTest.ts is the driver‚Äôs cockpit:\n // \t‚Ä¢\tIt gives you the dashboard (stats),\n // \t‚Ä¢\tThe steering wheel (handleInput),\n // \t‚Ä¢\tAnd the ignition/reset button (reset)\n // ‚∏ª\n // üì¶ What does useTypingTest actually do?\n // Here‚Äôs a super clear breakdown of each part:\n // ‚∏ª\n // 1. const [input, setInput] = useState('')\n // This is a React hook that stores the current string the user is typing.\n // So if the user types: The quick,\n // input === 'The quick'\n // This is what your UI will display and track live.\n // ‚∏ª\n // 2. const [stats, setStats] = useState<TypingStats | null>(null)\n // This holds the live stats coming from the engine:\n // \t‚Ä¢\tWPM\n // \t‚Ä¢\tAccuracy\n // \t‚Ä¢\tMistakes\n // After every keystroke, this will be updated and can be shown in the UI.\n // ‚∏ª\n // 3. const [isComplete, setIsComplete] = useState(false)\n // This tells the UI whether the typing test is done.\n // If the user finishes typing the whole paragraph, this becomes true.\n // You might use this to show a ‚ÄúCongrats‚Äù screen or to stop the timer.\n // ‚∏ª\n // 4. const [engine] = useState(() => new TypingTestEngine(targetText))\n // We create a new instance of your TypingTestEngine, passing in the sentence to type.\n // This engine will:\n // \t‚Ä¢\tStart the timer\n // \t‚Ä¢\tCompare the user‚Äôs input to the sentence\n // \t‚Ä¢\tTrack mistakes\n // We store it in React useState so that it doesn‚Äôt get reset on every re-render.\n // ‚∏ª\n // 5. handleInput(value)\n // This is the most important function.\n // Every time the user types a letter:\n // \t‚Ä¢\thandleInput() is called\n // \t‚Ä¢\tIt updates input state (so the UI shows the letters)\n // \t‚Ä¢\tIt sends the input to the engine\n // \t‚Ä¢\tIt updates the live stats\n // \t‚Ä¢\tIt checks if typing is complete\n // You‚Äôll pass this function to your input box ‚Äî and the whole loop is wired up.\n // ‚∏ª\n // 6. reset()\n // Resets everything:\n // \t‚Ä¢\tClears the input\n // \t‚Ä¢\tClears the stats\n // \t‚Ä¢\tRestarts the timer in the engine\n // You‚Äôll use this when the user wants to try again or when you load a new sentence.\n // ‚∏ª\n // 7. useEffect(() => { reset(); }, [targetText])\n // This makes sure the test is automatically reset when the sentence changes.\n // Imagine you press ‚ÄúNew Paragraph‚Äù ‚Äî it clears and starts over.\n // ‚∏ª\n // 8. What gets returned?\n // return {\n //   input,         // The string the user has typed so far\n //   stats,         // The live WPM, accuracy, mistakes, etc.\n //   isComplete,    // Whether the test is done\n //   handleInput,   // Function to call on every keypress\n //   reset,         // Function to reset the test\n // };\n // You‚Äôll use these directly inside TypingBox.tsx or your UI.\n // ‚∏ª\n // üß† Summary\n // Element\tWhat it is\tWhy it matters\n // input\tThe user‚Äôs current typing\tNeeded to display progress in real-time\n // handleInput\tCalled on every keypress\tUpdates engine + state\n // stats\tWhat comes out of the engine\tUsed for analytics/feedback after test\n // isComplete\tWhether they finished typing the sentence\tCan be used to trigger a results view\n // reset\tClears the test\tFor retry or changing sentences\n // ‚∏ª\n // ‚úÖ Do You Understand So Far?\n // Here‚Äôs a quick comprehension check ‚Äî feel free to answer casually:\n // \t1.\tIn your own words, what is the role of useTypingTest?\n // \t2.\tWhen might the reset() function be triggered?\n // \t3.\tWhy do we wrap the engine inside a hook instead of calling it directly in the component?\n // If you want, we can move to TypingBox.tsx next. But I‚Äôm happy to sit here with this part until you feel clear and confident.\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9tb2R1bGVzL3R5cGluZ1Rlc3QvdXRpbHMvdXNlVHlwaW5nVGVzdC50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQXlEO0FBQ0E7QUFFbEQsU0FBU0ksY0FBY0MsVUFBa0I7SUFDOUMsTUFBTSxDQUFDQyxPQUFPQyxTQUFTLEdBQUdQLCtDQUFRQSxDQUFDO0lBQ25DLE1BQU0sQ0FBQ1EsT0FBT0MsU0FBUyxHQUFHVCwrQ0FBUUEsQ0FBcUI7SUFDdkQsTUFBTSxDQUFDVSxZQUFZQyxjQUFjLEdBQUdYLCtDQUFRQSxDQUFDO0lBQzdDLE1BQU0sQ0FBQ1ksT0FBTyxHQUFHWiwrQ0FBUUEsQ0FBQyxJQUFNLElBQUlHLHFEQUFnQkEsQ0FBQ0U7SUFFckQsZ0RBQWdEO0lBQ2xELHFCQUFxQjtJQUNyQixpQ0FBaUM7SUFDakMsMkJBQTJCO0lBQzNCLDRDQUE0QztJQUM1Qyx5QkFBeUI7SUFDekIsd09BQXdPO0lBRXRPLE1BQU1RLGNBQWNYLGtEQUFXQSxDQUFDLENBQUNZO1FBQy9CUCxTQUFTTztRQUNULE1BQU1DLFdBQVdILE9BQU9JLFlBQVksQ0FBQ0Y7UUFDckNMLFNBQVNHLE9BQU9LLFFBQVE7UUFDeEJOLGNBQWNJO0lBQ2hCLEdBQUc7UUFBQ0g7S0FBTztJQUVYLE1BQU1NLFFBQVFoQixrREFBV0EsQ0FBQztRQUN4QkssU0FBUztRQUNURSxTQUFTO1FBQ1RFLGNBQWM7UUFDZEMsT0FBT08sS0FBSztJQUNkLEdBQUc7UUFBQ1A7S0FBTztJQUVYWCxnREFBU0EsQ0FBQztRQUNSaUI7SUFDRixHQUFHO1FBQUNiO1FBQVlhO0tBQU07SUFFdEIsT0FBTztRQUNMWjtRQUNBRTtRQUNBRTtRQUNBRztRQUNBSztJQUNGO0FBQ0YsRUFFQSw2TEFBNkw7Q0FFN0wsSUFBSTtDQUVKLG1GQUFtRjtDQUVuRixJQUFJO0NBRUosbURBQW1EO0NBRW5ELDhCQUE4QjtDQUM5Qix3REFBd0Q7Q0FDeEQsNkZBQTZGO0NBQzdGLG9FQUFvRTtDQUNwRSwrR0FBK0c7Q0FFL0csSUFBSTtDQUVKLDRCQUE0QjtDQUU1QixxQ0FBcUM7Q0FFckMsdUhBQXVIO0NBRXZILDRDQUE0QztDQUM1Qyx5Q0FBeUM7Q0FDekMsdUNBQXVDO0NBQ3ZDLDJDQUEyQztDQUUzQyxJQUFJO0NBRUosMENBQTBDO0NBRTFDLCtDQUErQztDQUUvQyxJQUFJO0NBRUosNENBQTRDO0NBRTVDLDBFQUEwRTtDQUUxRSxtQ0FBbUM7Q0FDbkMsd0JBQXdCO0NBRXhCLG9EQUFvRDtDQUVwRCxJQUFJO0NBRUosa0VBQWtFO0NBRWxFLG9EQUFvRDtDQUNwRCxTQUFTO0NBQ1QsY0FBYztDQUNkLGNBQWM7Q0FFZCwwRUFBMEU7Q0FFMUUsSUFBSTtDQUVKLHlEQUF5RDtDQUV6RCxxREFBcUQ7Q0FFckQsc0VBQXNFO0NBRXRFLHVFQUF1RTtDQUV2RSxJQUFJO0NBRUosdUVBQXVFO0NBRXZFLHNGQUFzRjtDQUV0RixvQkFBb0I7Q0FDcEIscUJBQXFCO0NBQ3JCLDhDQUE4QztDQUM5QyxvQkFBb0I7Q0FFcEIsaUZBQWlGO0NBRWpGLElBQUk7Q0FFSix3QkFBd0I7Q0FFeEIsdUNBQXVDO0NBRXZDLHNDQUFzQztDQUN0Qyw2QkFBNkI7Q0FDN0IsMERBQTBEO0NBQzFELHNDQUFzQztDQUN0QywrQkFBK0I7Q0FDL0IscUNBQXFDO0NBRXJDLGdGQUFnRjtDQUVoRixJQUFJO0NBRUosYUFBYTtDQUViLHFCQUFxQjtDQUNyQixzQkFBc0I7Q0FDdEIsc0JBQXNCO0NBQ3RCLHNDQUFzQztDQUV0QyxvRkFBb0Y7Q0FFcEYsSUFBSTtDQUVKLGlEQUFpRDtDQUVqRCw2RUFBNkU7Q0FFN0UsaUVBQWlFO0NBRWpFLElBQUk7Q0FFSix5QkFBeUI7Q0FFekIsV0FBVztDQUNYLDJEQUEyRDtDQUMzRCw2REFBNkQ7Q0FDN0QsK0NBQStDO0NBQy9DLHlEQUF5RDtDQUN6RCxpREFBaUQ7Q0FDakQsS0FBSztDQUVMLDZEQUE2RDtDQUU3RCxJQUFJO0NBRUosYUFBYTtDQUViLG9DQUFvQztDQUNwQywwRUFBMEU7Q0FDMUUsOERBQThEO0NBQzlELDRFQUE0RTtDQUM1RSw2RkFBNkY7Q0FDN0Ysd0RBQXdEO0NBSXhELElBQUk7Q0FFSiw4QkFBOEI7Q0FFOUIscUVBQXFFO0NBQ3JFLDREQUE0RDtDQUM1RCxvREFBb0Q7Q0FDcEQsK0ZBQStGO0NBRS9GLCtIQUErSCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvbW9kdWxlcy90eXBpbmdUZXN0L3V0aWxzL3VzZVR5cGluZ1Rlc3QudHM/ZGZmZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1c2VTdGF0ZSwgdXNlRWZmZWN0LCB1c2VDYWxsYmFjayB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IFR5cGluZ1Rlc3RFbmdpbmUsIFR5cGluZ1N0YXRzIH0gZnJvbSAnLi9lbmdpbmUnO1xuXG5leHBvcnQgZnVuY3Rpb24gdXNlVHlwaW5nVGVzdCh0YXJnZXRUZXh0OiBzdHJpbmcpIHtcbiAgY29uc3QgW2lucHV0LCBzZXRJbnB1dF0gPSB1c2VTdGF0ZSgnJyk7XG4gIGNvbnN0IFtzdGF0cywgc2V0U3RhdHNdID0gdXNlU3RhdGU8VHlwaW5nU3RhdHMgfCBudWxsPihudWxsKTtcbiAgY29uc3QgW2lzQ29tcGxldGUsIHNldElzQ29tcGxldGVdID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbZW5naW5lXSA9IHVzZVN0YXRlKCgpID0+IG5ldyBUeXBpbmdUZXN0RW5naW5lKHRhcmdldFRleHQpKTtcblxuICAvLyBmdW5jdGlvbiB1c2VUeXBpbmdUZXN0KHRhcmdldFRleHQ6IHN0cmluZyk6IHtcbi8vICAgICBpbnB1dDogc3RyaW5nO1xuLy8gICAgIHN0YXRzOiBUeXBpbmdTdGF0cyB8IG51bGw7XG4vLyAgICAgaXNDb21wbGV0ZTogYm9vbGVhbjtcbi8vICAgICBoYW5kbGVJbnB1dDogKHZhbHVlOiBzdHJpbmcpID0+IHZvaWQ7XG4vLyAgICAgcmVzZXQ6ICgpID0+IHZvaWQ7XG4vLyB9ICAgd2h5IGlzIHRoaXMgaW4gcmVkID8gYmVjYXVzZSBpdCBpcyBub3QgdXNlZCAtIHdoeSBpcyBpdCBub3QgdXNlZCA/IGJlY2F1c2UgaXQgaXMgbm90IHVzZWQgaW4gdGhlIGFwcC50c3ggZmlsZSAtIHNob3VsZCBpIHJlbW92ZSBpdCA/IHllcyAtIHRoZSBmdW5jdGlvbiBpcyBhbHJlYWR5IGRlZmluZWQgaW4gdGhlIGVuZ2luZS50cyBmaWxlLCBzbyBpIGNhbiByZW1vdmUgaXQgZnJvbSBoZXJlLiAgXG5cbiAgY29uc3QgaGFuZGxlSW5wdXQgPSB1c2VDYWxsYmFjaygodmFsdWU6IHN0cmluZykgPT4ge1xuICAgIHNldElucHV0KHZhbHVlKTtcbiAgICBjb25zdCBjb21wbGV0ZSA9IGVuZ2luZS5wcm9jZXNzSW5wdXQodmFsdWUpO1xuICAgIHNldFN0YXRzKGVuZ2luZS5nZXRTdGF0cygpKTtcbiAgICBzZXRJc0NvbXBsZXRlKGNvbXBsZXRlKTtcbiAgfSwgW2VuZ2luZV0pO1xuXG4gIGNvbnN0IHJlc2V0ID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIHNldElucHV0KCcnKTtcbiAgICBzZXRTdGF0cyhudWxsKTtcbiAgICBzZXRJc0NvbXBsZXRlKGZhbHNlKTtcbiAgICBlbmdpbmUuc3RhcnQoKTtcbiAgfSwgW2VuZ2luZV0pO1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgcmVzZXQoKTtcbiAgfSwgW3RhcmdldFRleHQsIHJlc2V0XSk7XG5cbiAgcmV0dXJuIHtcbiAgICBpbnB1dCxcbiAgICBzdGF0cyxcbiAgICBpc0NvbXBsZXRlLFxuICAgIGhhbmRsZUlucHV0LFxuICAgIHJlc2V0LFxuICB9O1xufSBcblxuLy9ZZXMsIEkgZnVsbHkgdW5kZXJzdGFuZCB5b3VyIHByb21wdCDigJQgYW5kIEkgcmVhbGx5IGxpa2UgeW91ciBhcHByb2FjaC4gWW914oCZcmUgbm90IGp1c3QgdHJ5aW5nIHRvIGJ1aWxkIHF1aWNrbHkg4oCUIHlvdeKAmXJlIHRyeWluZyB0byB1bmRlcnN0YW5kIGRlZXBseSwgd2hpY2ggaXMgaG93IHJlYWwgbWFzdGVyeSBpcyBidWlsdC4g8J+UpVxuXG4vLyDiuLtcblxuLy8gTGV04oCZcyBzbG93IGl0IGRvd24gYW5kIHdhbGsgdGhyb3VnaCB0aGlzIHN0ZXAtYnktc3RlcCB3aXRoIHlvdXIgY29udGV4dCBpbiBtaW5kLlxuXG4vLyDiuLtcblxuLy8g8J+noCBCaWcgUGljdHVyZTogV2hlcmUgZG9lcyB1c2VUeXBpbmdUZXN0IGZpdCBpbj9cblxuLy8g8J+SoSBZb3UgYWxyZWFkeSBuYWlsZWQgdGhpczpcbi8vIFx04oCiXHRlbmdpbmUudHMgPSByYXcgbG9naWMgZm9yIGNhbGN1bGF0aW5nIHR5cGluZyBzdGF0c1xuLy8gXHTigKJcdHVzZVR5cGluZ1Rlc3QudHMgPSB3cmFwcyB0aGF0IGxvZ2ljIGluIGEgd2F5IFJlYWN0IGNvbXBvbmVudHMgY2FuIHNhZmVseSBhbmQgZWFzaWx5IHVzZVxuLy8gXHTigKJcdOKchSBJdCBjb25uZWN0cyB0aGUgUmVhY3Qgc3RhdGUgYW5kIFVJIHRvIHRoZSBsb2dpYyBpbiBlbmdpbmUudHNcbi8vIFx04oCiXHTinIUgSXQgZXhwb3NlcyB1c2VmdWwgZGF0YSAoaW5wdXQsIHN0YXRzLCBpc0NvbXBsZXRlKSBhbmQgZnVuY3Rpb25zIChoYW5kbGVJbnB1dCwgcmVzZXQpIHRvIHlvdXIgY29tcG9uZW50c1xuXG4vLyDiuLtcblxuLy8g8J+nqSBUaGluayBvZiBpdCBsaWtlIHRoaXM6XG5cbi8vIEltYWdpbmUgZW5naW5lLnRzIGlzIGEgY2FyIGVuZ2luZS5cblxuLy8gSXQga25vd3MgaG93IHRvIGRyaXZlIOKAlCBidXQgaXTigJlzIHJhdywgbWVjaGFuaWNhbCwgYW5kIGRvZXNu4oCZdCBjb21lIHdpdGggYSBzdGVlcmluZyB3aGVlbCwgZGFzaGJvYXJkLCBvciBzcGVlZG9tZXRlci5cblxuLy8gdXNlVHlwaW5nVGVzdC50cyBpcyB0aGUgZHJpdmVy4oCZcyBjb2NrcGl0OlxuLy8gXHTigKJcdEl0IGdpdmVzIHlvdSB0aGUgZGFzaGJvYXJkIChzdGF0cyksXG4vLyBcdOKAolx0VGhlIHN0ZWVyaW5nIHdoZWVsIChoYW5kbGVJbnB1dCksXG4vLyBcdOKAolx0QW5kIHRoZSBpZ25pdGlvbi9yZXNldCBidXR0b24gKHJlc2V0KVxuXG4vLyDiuLtcblxuLy8g8J+TpiBXaGF0IGRvZXMgdXNlVHlwaW5nVGVzdCBhY3R1YWxseSBkbz9cblxuLy8gSGVyZeKAmXMgYSBzdXBlciBjbGVhciBicmVha2Rvd24gb2YgZWFjaCBwYXJ0OlxuXG4vLyDiuLtcblxuLy8gMS4gY29uc3QgW2lucHV0LCBzZXRJbnB1dF0gPSB1c2VTdGF0ZSgnJylcblxuLy8gVGhpcyBpcyBhIFJlYWN0IGhvb2sgdGhhdCBzdG9yZXMgdGhlIGN1cnJlbnQgc3RyaW5nIHRoZSB1c2VyIGlzIHR5cGluZy5cblxuLy8gU28gaWYgdGhlIHVzZXIgdHlwZXM6IFRoZSBxdWljayxcbi8vIGlucHV0ID09PSAnVGhlIHF1aWNrJ1xuXG4vLyBUaGlzIGlzIHdoYXQgeW91ciBVSSB3aWxsIGRpc3BsYXkgYW5kIHRyYWNrIGxpdmUuXG5cbi8vIOK4u1xuXG4vLyAyLiBjb25zdCBbc3RhdHMsIHNldFN0YXRzXSA9IHVzZVN0YXRlPFR5cGluZ1N0YXRzIHwgbnVsbD4obnVsbClcblxuLy8gVGhpcyBob2xkcyB0aGUgbGl2ZSBzdGF0cyBjb21pbmcgZnJvbSB0aGUgZW5naW5lOlxuLy8gXHTigKJcdFdQTVxuLy8gXHTigKJcdEFjY3VyYWN5XG4vLyBcdOKAolx0TWlzdGFrZXNcblxuLy8gQWZ0ZXIgZXZlcnkga2V5c3Ryb2tlLCB0aGlzIHdpbGwgYmUgdXBkYXRlZCBhbmQgY2FuIGJlIHNob3duIGluIHRoZSBVSS5cblxuLy8g4ri7XG5cbi8vIDMuIGNvbnN0IFtpc0NvbXBsZXRlLCBzZXRJc0NvbXBsZXRlXSA9IHVzZVN0YXRlKGZhbHNlKVxuXG4vLyBUaGlzIHRlbGxzIHRoZSBVSSB3aGV0aGVyIHRoZSB0eXBpbmcgdGVzdCBpcyBkb25lLlxuXG4vLyBJZiB0aGUgdXNlciBmaW5pc2hlcyB0eXBpbmcgdGhlIHdob2xlIHBhcmFncmFwaCwgdGhpcyBiZWNvbWVzIHRydWUuXG5cbi8vIFlvdSBtaWdodCB1c2UgdGhpcyB0byBzaG93IGEg4oCcQ29uZ3JhdHPigJ0gc2NyZWVuIG9yIHRvIHN0b3AgdGhlIHRpbWVyLlxuXG4vLyDiuLtcblxuLy8gNC4gY29uc3QgW2VuZ2luZV0gPSB1c2VTdGF0ZSgoKSA9PiBuZXcgVHlwaW5nVGVzdEVuZ2luZSh0YXJnZXRUZXh0KSlcblxuLy8gV2UgY3JlYXRlIGEgbmV3IGluc3RhbmNlIG9mIHlvdXIgVHlwaW5nVGVzdEVuZ2luZSwgcGFzc2luZyBpbiB0aGUgc2VudGVuY2UgdG8gdHlwZS5cblxuLy8gVGhpcyBlbmdpbmUgd2lsbDpcbi8vIFx04oCiXHRTdGFydCB0aGUgdGltZXJcbi8vIFx04oCiXHRDb21wYXJlIHRoZSB1c2Vy4oCZcyBpbnB1dCB0byB0aGUgc2VudGVuY2Vcbi8vIFx04oCiXHRUcmFjayBtaXN0YWtlc1xuXG4vLyBXZSBzdG9yZSBpdCBpbiBSZWFjdCB1c2VTdGF0ZSBzbyB0aGF0IGl0IGRvZXNu4oCZdCBnZXQgcmVzZXQgb24gZXZlcnkgcmUtcmVuZGVyLlxuXG4vLyDiuLtcblxuLy8gNS4gaGFuZGxlSW5wdXQodmFsdWUpXG5cbi8vIFRoaXMgaXMgdGhlIG1vc3QgaW1wb3J0YW50IGZ1bmN0aW9uLlxuXG4vLyBFdmVyeSB0aW1lIHRoZSB1c2VyIHR5cGVzIGEgbGV0dGVyOlxuLy8gXHTigKJcdGhhbmRsZUlucHV0KCkgaXMgY2FsbGVkXG4vLyBcdOKAolx0SXQgdXBkYXRlcyBpbnB1dCBzdGF0ZSAoc28gdGhlIFVJIHNob3dzIHRoZSBsZXR0ZXJzKVxuLy8gXHTigKJcdEl0IHNlbmRzIHRoZSBpbnB1dCB0byB0aGUgZW5naW5lXG4vLyBcdOKAolx0SXQgdXBkYXRlcyB0aGUgbGl2ZSBzdGF0c1xuLy8gXHTigKJcdEl0IGNoZWNrcyBpZiB0eXBpbmcgaXMgY29tcGxldGVcblxuLy8gWW914oCZbGwgcGFzcyB0aGlzIGZ1bmN0aW9uIHRvIHlvdXIgaW5wdXQgYm94IOKAlCBhbmQgdGhlIHdob2xlIGxvb3AgaXMgd2lyZWQgdXAuXG5cbi8vIOK4u1xuXG4vLyA2LiByZXNldCgpXG5cbi8vIFJlc2V0cyBldmVyeXRoaW5nOlxuLy8gXHTigKJcdENsZWFycyB0aGUgaW5wdXRcbi8vIFx04oCiXHRDbGVhcnMgdGhlIHN0YXRzXG4vLyBcdOKAolx0UmVzdGFydHMgdGhlIHRpbWVyIGluIHRoZSBlbmdpbmVcblxuLy8gWW914oCZbGwgdXNlIHRoaXMgd2hlbiB0aGUgdXNlciB3YW50cyB0byB0cnkgYWdhaW4gb3Igd2hlbiB5b3UgbG9hZCBhIG5ldyBzZW50ZW5jZS5cblxuLy8g4ri7XG5cbi8vIDcuIHVzZUVmZmVjdCgoKSA9PiB7IHJlc2V0KCk7IH0sIFt0YXJnZXRUZXh0XSlcblxuLy8gVGhpcyBtYWtlcyBzdXJlIHRoZSB0ZXN0IGlzIGF1dG9tYXRpY2FsbHkgcmVzZXQgd2hlbiB0aGUgc2VudGVuY2UgY2hhbmdlcy5cblxuLy8gSW1hZ2luZSB5b3UgcHJlc3Mg4oCcTmV3IFBhcmFncmFwaOKAnSDigJQgaXQgY2xlYXJzIGFuZCBzdGFydHMgb3Zlci5cblxuLy8g4ri7XG5cbi8vIDguIFdoYXQgZ2V0cyByZXR1cm5lZD9cblxuLy8gcmV0dXJuIHtcbi8vICAgaW5wdXQsICAgICAgICAgLy8gVGhlIHN0cmluZyB0aGUgdXNlciBoYXMgdHlwZWQgc28gZmFyXG4vLyAgIHN0YXRzLCAgICAgICAgIC8vIFRoZSBsaXZlIFdQTSwgYWNjdXJhY3ksIG1pc3Rha2VzLCBldGMuXG4vLyAgIGlzQ29tcGxldGUsICAgIC8vIFdoZXRoZXIgdGhlIHRlc3QgaXMgZG9uZVxuLy8gICBoYW5kbGVJbnB1dCwgICAvLyBGdW5jdGlvbiB0byBjYWxsIG9uIGV2ZXJ5IGtleXByZXNzXG4vLyAgIHJlc2V0LCAgICAgICAgIC8vIEZ1bmN0aW9uIHRvIHJlc2V0IHRoZSB0ZXN0XG4vLyB9O1xuXG4vLyBZb3XigJlsbCB1c2UgdGhlc2UgZGlyZWN0bHkgaW5zaWRlIFR5cGluZ0JveC50c3ggb3IgeW91ciBVSS5cblxuLy8g4ri7XG5cbi8vIPCfp6AgU3VtbWFyeVxuXG4vLyBFbGVtZW50XHRXaGF0IGl0IGlzXHRXaHkgaXQgbWF0dGVyc1xuLy8gaW5wdXRcdFRoZSB1c2Vy4oCZcyBjdXJyZW50IHR5cGluZ1x0TmVlZGVkIHRvIGRpc3BsYXkgcHJvZ3Jlc3MgaW4gcmVhbC10aW1lXG4vLyBoYW5kbGVJbnB1dFx0Q2FsbGVkIG9uIGV2ZXJ5IGtleXByZXNzXHRVcGRhdGVzIGVuZ2luZSArIHN0YXRlXG4vLyBzdGF0c1x0V2hhdCBjb21lcyBvdXQgb2YgdGhlIGVuZ2luZVx0VXNlZCBmb3IgYW5hbHl0aWNzL2ZlZWRiYWNrIGFmdGVyIHRlc3Rcbi8vIGlzQ29tcGxldGVcdFdoZXRoZXIgdGhleSBmaW5pc2hlZCB0eXBpbmcgdGhlIHNlbnRlbmNlXHRDYW4gYmUgdXNlZCB0byB0cmlnZ2VyIGEgcmVzdWx0cyB2aWV3XG4vLyByZXNldFx0Q2xlYXJzIHRoZSB0ZXN0XHRGb3IgcmV0cnkgb3IgY2hhbmdpbmcgc2VudGVuY2VzXG5cblxuXG4vLyDiuLtcblxuLy8g4pyFIERvIFlvdSBVbmRlcnN0YW5kIFNvIEZhcj9cblxuLy8gSGVyZeKAmXMgYSBxdWljayBjb21wcmVoZW5zaW9uIGNoZWNrIOKAlCBmZWVsIGZyZWUgdG8gYW5zd2VyIGNhc3VhbGx5OlxuLy8gXHQxLlx0SW4geW91ciBvd24gd29yZHMsIHdoYXQgaXMgdGhlIHJvbGUgb2YgdXNlVHlwaW5nVGVzdD9cbi8vIFx0Mi5cdFdoZW4gbWlnaHQgdGhlIHJlc2V0KCkgZnVuY3Rpb24gYmUgdHJpZ2dlcmVkP1xuLy8gXHQzLlx0V2h5IGRvIHdlIHdyYXAgdGhlIGVuZ2luZSBpbnNpZGUgYSBob29rIGluc3RlYWQgb2YgY2FsbGluZyBpdCBkaXJlY3RseSBpbiB0aGUgY29tcG9uZW50P1xuXG4vLyBJZiB5b3Ugd2FudCwgd2UgY2FuIG1vdmUgdG8gVHlwaW5nQm94LnRzeCBuZXh0LiBCdXQgSeKAmW0gaGFwcHkgdG8gc2l0IGhlcmUgd2l0aCB0aGlzIHBhcnQgdW50aWwgeW91IGZlZWwgY2xlYXIgYW5kIGNvbmZpZGVudC4iXSwibmFtZXMiOlsidXNlU3RhdGUiLCJ1c2VFZmZlY3QiLCJ1c2VDYWxsYmFjayIsIlR5cGluZ1Rlc3RFbmdpbmUiLCJ1c2VUeXBpbmdUZXN0IiwidGFyZ2V0VGV4dCIsImlucHV0Iiwic2V0SW5wdXQiLCJzdGF0cyIsInNldFN0YXRzIiwiaXNDb21wbGV0ZSIsInNldElzQ29tcGxldGUiLCJlbmdpbmUiLCJoYW5kbGVJbnB1dCIsInZhbHVlIiwiY29tcGxldGUiLCJwcm9jZXNzSW5wdXQiLCJnZXRTdGF0cyIsInJlc2V0Iiwic3RhcnQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/modules/typingTest/utils/useTypingTest.ts\n"));

/***/ })

});